// Generated by CoffeeScript 1.3.3
(function() {
  var Telemachus, addTelemetry, calculateTicks, charts, customCharts, customLayouts, dateString, defaultLayout, drawChartAxes, drawChartGrid, drawChartLegend, drawChartSeries, durationString, hourMinSec, layouts, missionTimeString, orderOfMagnitude, reloadLayout, removeTelemetry, resetChart, setChart, setLayout, siUnit, standardCharts, standardLayouts, stripInsignificantZeros, testCharts, testLayouts,
    __slice = [].slice;

  standardCharts = {
    "Altitude": {
      series: ["v.altitude", "v.heightFromTerrain"],
      yaxis: {
        label: "Altitude",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Apoapsis and Periapsis": {
      series: ["o.ApA", "o.PeA"],
      yaxis: {
        label: "Altitude",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Atmospheric Density": {
      series: ["v.atmosphericDensity"],
      yaxis: {
        label: "Altitude",
        unit: "Pa",
        min: 0,
        max: null
      }
    },
    "Dynamic Pressure": {
      series: ["v.dynamicPressure"],
      yaxis: {
        label: "Dynamic Pressure",
        unit: "Pa",
        min: 0,
        max: null
      }
    },
    "G-Force": {
      series: ["s.sensor.acc"],
      yaxis: {
        label: "Acceleration",
        unit: "Gs",
        min: null,
        max: null
      }
    },
    "Gravity": {
      series: ["s.sensor.grav"],
      yaxis: {
        label: "Gravity",
        unit: "m/s\u00B2",
        min: 0,
        max: null
      }
    },
    "Pressure": {
      series: ["s.sensor.pres"],
      yaxis: {
        label: "Pressure",
        unit: "Pa",
        min: 0,
        max: null
      }
    },
    "Temperature": {
      series: ["s.sensor.temp"],
      yaxis: {
        label: "Temperature",
        unit: "\u00B0C",
        min: null,
        max: null
      }
    },
    "Orbital Velocity": {
      series: ["v.orbitalVelocity"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    },
    "Surface Velocity": {
      series: ["v.surfaceSpeed", "v.verticalSpeed"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: null,
        max: null
      }
    },
    "Angular Velocity": {
      series: ["v.angularVelocity"],
      yaxis: {
        label: "Angular Velocity",
        unit: "\u00B0/s",
        min: 0,
        max: null
      }
    },
    "Liquid Fuel and Oxidizer": {
      series: ["r.resource[LiquidFuel]", "r.resource[Oxidizer]"],
      yaxis: {
        label: "Volume",
        unit: "L",
        min: 0,
        max: null
      }
    },
    "Electric Charge": {
      series: ["r.resource[ElectricCharge]"],
      yaxis: {
        label: "Electric Charge",
        unit: "Wh",
        min: 0,
        max: null
      }
    },
    "Monopropellant": {
      series: ["r.resource[MonoPropellant]"],
      yaxis: {
        label: "Volume",
        unit: "L",
        min: 0,
        max: null
      }
    },
    "Heading": {
      series: ["n.heading"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: 0,
        max: 360
      }
    },
    "Pitch": {
      series: ["n.pitch"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: -90,
        max: 90
      }
    },
    "Roll": {
      series: ["n.roll"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: -180,
        max: 180
      }
    },
    "Target Distance": {
      series: ["tar.distance"],
      yaxis: {
        label: "Distance",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Relative Velocity": {
      series: ["tar.o.relativeVelocity"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    },
    "True Anomaly": {
      series: ["o.trueAnomaly"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: null,
        max: null
      }
    },
    "Map": {
      series: ["v.long", "v.lat", "v.name", "v.body"],
      type: "map"
    }
  };

  testCharts = {
    "Sine and Cosine": {
      series: ["test.sin", "test.cos"],
      yaxis: {
        label: "Angle",
        unit: "\u00B0",
        min: null,
        max: null
      }
    },
    "Quadratic": {
      series: ["test.square"],
      yaxis: {
        label: "Altitude",
        unit: "m",
        min: 0,
        max: null
      }
    },
    "Random": {
      series: ["test.rand"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    },
    "Square Root": {
      series: ["test.sqrt"],
      yaxis: {
        label: "Velocity",
        unit: "m/s",
        min: 0,
        max: null
      }
    }
  };

  customCharts = {};

  charts = {};

  standardLayouts = {
    "Flight Dynamics": {
      charts: ["Altitude", "Orbital Velocity", "True Anomaly"],
      telemetry: ["o.sma", "o.eccentricity", "o.inclination", "o.lan", "o.argumentOfPeriapsis", "o.timeOfPeriapsisPassage", "o.trueAnomaly", "v.altitude", "v.orbitalVelocity"]
    },
    "Retrofire": {
      charts: ["Map", "Altitude", "Surface Velocity"],
      telemetry: ["v.altitude", "v.heightFromTerrain", "v.surfaceSpeed", "v.verticalSpeed", "v.lat", "v.long"]
    },
    "Booster Systems": {
      charts: ["Liquid Fuel and Oxidizer", "Dynamic Pressure", "Atmospheric Density"],
      telemetry: ["r.resource[LiquidFuel]", "r.resourceMax[LiquidFuel]", "r.resource[Oxidizer]", "r.resourceMax[Oxidizer]", "v.dynamicPressure", "v.atmosphericDensity"]
    },
    "Instrumentation": {
      charts: ["G-Force", "Pressure", "Temperature"],
      telemetry: ["s.sensor.acc", "s.sensor.pres", "s.sensor.temp", "s.sensor.grav"]
    },
    "Electrical, Environmental and Comm.": {
      charts: ["Electric Charge", "Pressure", "Temperature"],
      telemetry: ["r.resource[ElectricCharge]", "r.resourceMax[ElectricCharge]", "s.sensor.pres", "s.sensor.temp"]
    },
    "Guidance, Navigation and Control": {
      charts: ["Heading", "Pitch", "Roll"],
      telemetry: ["r.resource[MonoPropellant]", "r.resourceMax[MonoPropellant]", "n.heading", "n.pitch", "n.roll"]
    },
    "Rendezvous and Docking": {
      charts: ["Target Distance", "Relative Velocity"],
      telemetry: ["tar.name", "tar.o.sma", "tar.o.eccentricity", "tar.o.inclination", "tar.o.lan", "tar.o.argumentOfPeriapsis", "tar.o.timeOfPeriapsisPassage", "tar.o.trueAnomaly", "tar.distance", "tar.o.relativeVelocity"]
    }
  };

  testLayouts = {
    "Test": {
      charts: ["Sine and Cosine", "Quadratic", "Random"],
      telemetry: ['test.rand', 'test.sin', 'test.cos', 'test.square', 'test.exp', 'test.sqrt', 'test.log']
    }
  };

  customLayouts = {};

  layouts = {};

  defaultLayout = "Flight Dynamics";

  Telemachus = {
    CELESTIAL_BODIES: ["Kerbol", "Kerbin", "Mun", "Minmus", "Moho", "Eve", "Duna", "Ike", "Jool", "Laythe", "Vall", "Bop", "Tylo", "Gilly", "Pol", "Dres", "Eeloo"],
    RESOURCES: ["ElectricCharge", "SolidFuel", "LiquidFuel", "Oxidizer", "MonoPropellant", "IntakeAir", "XenonGas"],
    api: {},
    telemetry: {
      "p.paused": 0,
      "v.missionTime": 0,
      "t.universalTime": 0
    },
    lastUpdate: null,
    apiSubscriptionCounts: {
      "t.universalTime": 1,
      "v.missionTime": 1
    },
    $telemetrySubscribers: $(),
    $alertSubscribers: $(),
    format: function(value, api) {
      var units;
      if (!(value != null)) {
        return "No Data";
      } else if ($.isArray(value)) {
        return this.format(value[1][0], api);
      } else {
        units = this.api[api].units.toLowerCase();
        if (units in this.formatters) {
          return this.formatters[units](value);
        } else {
          return value.toString();
        }
      }
    },
    subscribe: function() {
      var $collection, api, apis, _i, _len, _ref;
      $collection = arguments[0], apis = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.$telemetrySubscribers = this.$telemetrySubscribers.add($collection);
      $collection.data("telemachus-api-subscriptions", apis);
      for (_i = 0, _len = apis.length; _i < _len; _i++) {
        api = apis[_i];
        this.apiSubscriptionCounts[api] = ((_ref = this.apiSubscriptionCounts[api]) != null ? _ref : 0) + $collection.length;
      }
      return $collection;
    },
    unsubscribe: function() {
      var $collection, api, apis, elem, _i, _j, _len, _len1;
      $collection = arguments[0], apis = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.$telemetrySubscribers = this.$telemetrySubscribers.not($collection);
      for (_i = 0, _len = $collection.length; _i < _len; _i++) {
        elem = $collection[_i];
        apis = $(elem).data("telemachus-api-subscriptions");
        console.log(elem, apis);
        if (apis != null) {
          for (_j = 0, _len1 = apis.length; _j < _len1; _j++) {
            api = apis[_j];
            if (!(api in this.apiSubscriptionCounts)) {
              continue;
            }
            this.apiSubscriptionCounts[api] = this.apiSubscriptionCounts[api] - 1;
            if (this.apiSubscriptionCounts[api] <= 0) {
              delete this.apiSubscriptionCounts[api];
            }
          }
        }
      }
      console.log(this.apiSubscriptionCounts);
      return $collection;
    },
    subscribeAlerts: function($collection) {
      return this.$alertSubscribers = this.$alertSubscribers.add($collection);
    },
    unsubscribeAlerts: function($collection) {
      return this.$alertSubscribers = this.$alertSubscribers.not($collection);
    },
    loadAPI: function(testMode) {
      var _this = this;
      if (testMode) {
        this.api = {
          "p.paused": {
            apistring: 'p.paused',
            name: "Paused",
            units: 'UNITLESS'
          },
          "v.missionTime": {
            apistring: 'v.missionTime',
            name: "Mission Time",
            units: 'TIME'
          },
          "t.universalTime": {
            apistring: 't.universalTime',
            name: "Universal Time",
            units: 'DATE'
          },
          "test.rand": {
            apistring: 'test.rand',
            name: "Random",
            units: 'UNITLESS'
          },
          "test.sin": {
            apistring: 'test.sin',
            name: "Sine",
            units: 'UNITLESS'
          },
          "test.cos": {
            apistring: 'test.cos',
            name: "Cosine",
            units: 'UNITLESS'
          },
          "test.square": {
            apistring: 'test.square',
            name: "Quadratic",
            units: 'UNITLESS'
          },
          "test.exp": {
            apistring: 'test.exp',
            name: "Exponential",
            units: 'UNITLESS'
          },
          "test.sqrt": {
            apistring: 'test.sqrt',
            name: "Square Root",
            units: 'UNITLESS'
          },
          "test.log": {
            apistring: 'test.log',
            name: "Logarithmic",
            units: 'UNITLESS'
          }
        };
        this.testStart = Date.now();
        this.testDownlink();
        return $.Deferred().resolve(this.api).promise();
      } else {
        return $.get("datalink", {
          api: "a.api"
        }, "json").then(function(data, textStatus, jqXHR) {
          var api, i, r, resourceApi, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
          _ref = JSON.parse(data).api;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            api = _ref[_i];
            if (api.apistring.match(/^b\./)) {
              for (i = _j = 0, _ref1 = _this.CELESTIAL_BODIES.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                _this.api[api.apistring + ("[" + i + "]")] = api;
              }
            } else if (api.apistring.match(/^r\./)) {
              if (api.apistring !== "r.resourceCurrent") {
                _ref2 = _this.RESOURCES;
                for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
                  r = _ref2[_k];
                  resourceApi = $.extend({}, api);
                  resourceApi.name = r.replace(/([a-z])([A-Z])/g, "$1 $2");
                  if (api.apistring.match(/Max$/)) {
                    resourceApi.name += " Max";
                  }
                  _this.api[api.apistring + ("[" + r + "]")] = resourceApi;
                }
              }
            } else if (api.plotable && api.apistring !== "s.sensor") {
              _this.api[api.apistring] = api;
            }
          }
          _this.downlink();
          return _this.api;
        }, function() {
          var timeout;
          _this.$alertSubscribers.trigger("telemetryAlert", ["No Signal Found"]);
          timeout = $.Deferred();
          setTimeout((function() {
            return timeout.resolve();
          }), 5000);
          return timeout.then(function() {
            return _this.loadAPI();
          });
        });
      }
    },
    downlink: function() {
      var api, i, key, query, url,
        _this = this;
      query = {};
      i = 0;
      query["p"] = "p.paused";
      for (api in this.apiSubscriptionCounts) {
        if (api !== "p.paused") {
          query["a" + (i++)] = api;
        }
      }
      url = "datalink?" + (((function() {
        var _results;
        _results = [];
        for (key in query) {
          api = query[key];
          _results.push("" + key + "=" + api);
        }
        return _results;
      })()).join("&"));
      return $.get(url).done(function(data, textStatus, jqXHR) {
        var value;
        try {
          data = JSON.parse(data);
        } catch (error) {
          _this.$alertSubscribers.trigger("telemetryAlert", ["Bad Data"]);
          setTimeout((function() {
            return _this.downlink();
          }), 5000);
          return;
        }
        _this.telemetry["p.paused"] = data.p;
        switch (data.p) {
          case 4:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Signal Lost"]);
            break;
          case 3:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Signal Terminated"]);
            break;
          case 2:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Signal Power Loss"]);
            break;
          case 1:
            _this.$alertSubscribers.trigger("telemetryAlert", ["Game Paused"]);
            break;
          case 0:
            _this.$alertSubscribers.trigger("telemetryAlert", [null]);
        }
        if (data.p !== 1) {
          _this.lastUpdate = Date.now();
          _this.telemetry = {};
          for (key in data) {
            value = data[key];
            if (data.p === 0 || ["p.paused", "v.missionTime", "t.universalTime"].indexOf(query[key]) !== -1) {
              _this.telemetry[query[key]] = value;
            } else {
              _this.telemetry[query[key]] = null;
            }
          }
          _this.$telemetrySubscribers.trigger("telemetry", [_this.telemetry]);
        }
        return setTimeout((function() {
          return _this.downlink();
        }), 500);
      }).fail(function() {
        _this.$alertSubscribers.trigger("telemetryAlert", ["No Signal Found"]);
        return setTimeout((function() {
          return _this.downlink();
        }), 5000);
      });
    },
    testDownlink: function() {
      var api, lastRand, paused, rand, t, x, _ref,
        _this = this;
      rand = Math.random() * 1000;
      paused = rand >= 10 ? 0 : Math.floor(rand / 2);
      switch (paused) {
        case 4:
          this.$alertSubscribers.trigger("telemetryAlert", ["Signal Lost"]);
          break;
        case 3:
          this.$alertSubscribers.trigger("telemetryAlert", ["Signal Terminated"]);
          break;
        case 2:
          this.$alertSubscribers.trigger("telemetryAlert", ["Signal Power Loss"]);
          break;
        case 1:
          this.$alertSubscribers.trigger("telemetryAlert", ["Game Paused"]);
          break;
        case 0:
          this.$alertSubscribers.trigger("telemetryAlert", [null]);
      }
      if (paused !== 1) {
        this.lastUpdate = Date.now();
        t = (this.lastUpdate - this.testStart) / 1000;
        lastRand = (_ref = this.telemetry["test.rand"]) != null ? _ref : rand;
        this.telemetry = {
          "p.paused": paused,
          "v.missionTime": t,
          "t.universalTime": this.lastUpdate / 1000
        };
        x = t / 120;
        for (api in this.apiSubscriptionCounts) {
          if (!(api in this.telemetry)) {
            this.telemetry[api] = (function() {
              if (paused !== 0) {
                return null;
              } else {
                switch (api) {
                  case 'test.rand':
                    return lastRand + (rand - 500) / 10;
                  case 'test.sin':
                    return 1000 * Math.sin(x * 2 * Math.PI);
                  case 'test.cos':
                    return 1000 * Math.cos(x * 2 * Math.PI);
                  case 'test.square':
                    return x * x;
                  case 'test.exp':
                    return Math.exp(x);
                  case 'test.sqrt':
                    return Math.sqrt(x);
                  case 'test.log':
                    return Math.log(x);
                }
              }
            })();
          }
        }
        this.$telemetrySubscribers.trigger("telemetry", [this.telemetry]);
      }
      return setTimeout((function() {
        return _this.testDownlink();
      }), paused === 0 ? 500 : 5000);
    },
    formatters: {
      unitless: function(v) {
        if (typeof v === "number") {
          return v.toPrecision(6);
        } else {
          return v;
        }
      },
      velocity: function(v) {
        return siUnit(v, "m/s");
      },
      deg: function(v) {
        return v.toPrecision(6) + "\u00B0";
      },
      distance: function(v) {
        return siUnit(v, "m");
      },
      time: function(v) {
        return durationString(v);
      },
      string: function(v) {
        return v;
      },
      temp: function(v) {
        return v.toPrecision(6) + "\u00B0C";
      },
      pres: function(v) {
        return siUnit(v / 1000, "Pa");
      },
      grav: function(v) {
        return siUnit(v, "m/s\u00B2");
      },
      acc: function(v) {
        return v.toPrecision(6) + " G";
      },
      date: function(v) {
        return dateString(v);
      }
    }
  };

  $(document).ready(function() {
    var $chartMenus, $layoutMenu, chart, populateLayoutMenu, savedDefault, testMode, _ref, _ref1;
    if (window.localStorage != null) {
      customCharts = (_ref = JSON.parse(window.localStorage.getItem("telemachus.console.charts"))) != null ? _ref : {};
      $.extend(charts, standardCharts, customCharts);
      customLayouts = (_ref1 = JSON.parse(window.localStorage.getItem("telemachus.console.layouts"))) != null ? _ref1 : {};
      $.extend(layouts, standardLayouts, customLayouts);
      savedDefault = window.localStorage.getItem("defaultLayout");
      if ((savedDefault != null) && savedDefault in layouts) {
        defaultLayout = savedDefault;
      }
    }
    testMode = window.location.protocol === "file:" || window.location.hash === "#test";
    if (testMode) {
      $.extend(layouts, testLayouts);
      $.extend(charts, testCharts);
      defaultLayout = "Test";
    }
    $layoutMenu = $("body > header nav ul");
    populateLayoutMenu = function() {
      var layout, _results;
      $layoutMenu.empty();
      _results = [];
      for (layout in layouts) {
        _results.push($layoutMenu.append($("<li>").append($("<a>").attr({
          href: "#"
        }).text(layout))));
      }
      return _results;
    };
    populateLayoutMenu();
    $layoutMenu.on("click", "li a", function(event) {
      var layoutName;
      event.preventDefault();
      layoutName = $(this).text().trim();
      setLayout(layoutName);
      $("#deleteLayout").prop("disabled", !(layoutName in customLayouts));
      return $(this).closest("ul").hide();
    });
    $chartMenus = $(".chart nav ul");
    for (chart in charts) {
      $chartMenus.append($("<li>").append($("<a>").attr({
        href: "#"
      }).text(chart)));
    }
    $chartMenus.on("click", "li a", function(event) {
      event.preventDefault();
      setChart($(this).closest(".chart"), $(this).text());
      return $(this).closest("ul").hide();
    });
    $(document).on("click.dropdown", ".dropdown > a", function() {
      var $menu, $this;
      $this = $(this);
      $menu = $this.next();
      return $menu.toggle().css({
        left: Math.max($this.position().left + $this.width() - $menu.outerWidth(), 0),
        top: $this.position().top + Math.min($(window).height() - $menu.outerHeight() - $this.offset().top, $this.height())
      });
    });
    $(document).on("click.dropdown", function() {
      return $(".dropdown").not($(event.target).parents()).children("ul").hide();
    });
    setLayout(defaultLayout);
    $("#deleteLayout").prop("disabled", !(defaultLayout in customLayouts));
    $("#apiCategory").change(function(event) {
      var api, apistring, category, _ref2, _results;
      category = $("#apiCategory").val();
      $("#apiSelect").empty();
      _ref2 = Telemachus.api;
      _results = [];
      for (apistring in _ref2) {
        api = _ref2[apistring];
        if (apistring.match(category)) {
          _results.push($("#apiSelect").append($("<option>").attr("value", apistring).text(api.name)));
        }
      }
      return _results;
    });
    $("#telemetry").on("click", "dt a", function(event) {
      event.preventDefault();
      return removeTelemetry($(this).parent());
    });
    $(".alert").on("telemetryAlert", function(event, message) {
      var $display, $this;
      $(".alert").text(message != null ? message : "");
      if (message != null) {
        $this = $(this);
        $display = $this.siblings(".display");
        return $this.css("marginTop", -($display.outerHeight() + $this.height()) / 2);
      }
    });
    if (window.localStorage != null) {
      $("#saveLayout").click(function(event) {
        var elem, name;
        event.preventDefault();
        name = window.prompt("What name would you like to save this layout under?", $("h1").text().trim()).trim();
        if (!(name != null) || name === "" || (name in layouts && !window.confirm("That name is already in use. Are you sure you want to overwrite the existing layout?"))) {
          return;
        }
        layouts[name] = customLayouts[name] = {
          charts: (function() {
            var _i, _len, _ref2, _results;
            _ref2 = $(".chart h2");
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              elem = _ref2[_i];
              _results.push($(elem).text().trim());
            }
            return _results;
          })(),
          telemetry: (function() {
            var _i, _len, _ref2, _results;
            _ref2 = $("#telemetry dt");
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              elem = _ref2[_i];
              _results.push($(elem).data("api"));
            }
            return _results;
          })()
        };
        window.localStorage.setItem("telemachus.console.layouts", JSON.stringify(customLayouts));
        populateLayoutMenu();
        $("h1").text(name);
        return $("#deleteLayout").prop("disabled", false);
      });
      $("#deleteLayout").click(function(event) {
        var layoutName;
        event.preventDefault();
        if (window.confirm("Are you sure you want to delete the current custom layout?")) {
          layoutName = $("h1").text().trim();
          if (!(layoutName in customLayouts)) {
            return;
          }
          delete customLayouts[layoutName];
          window.localStorage.setItem("telemachus.console.layouts", JSON.stringify(customLayouts));
          console.log("hello");
          if (layoutName in standardLayouts) {
            layouts[layoutName] = standardLayouts[layoutName];
            reloadLayout();
            return $("#deleteLayout").prop("disabled", true);
          } else {
            delete layouts[layoutName];
            populateLayoutMenu();
            return $("body > header nav ul li:first-child a").click();
          }
        }
      });
    } else {
      $("#saveLayout").prop("disabled", true);
      $("#deleteLayout").prop("disabled", true);
    }
    Telemachus.subscribeAlerts($(".alert"));
    Telemachus.loadAPI(testMode).done(function() {
      $("#apiCategory").change();
      return reloadLayout();
    });
    setInterval(function() {
      var missionTime, universalTime;
      if (Telemachus.telemetry["p.paused"] !== 1) {
        missionTime = Telemachus.telemetry["v.missionTime"];
        if (missionTime > 0) {
          missionTime += (Date.now() - Telemachus.lastUpdate) / 1000;
        }
        universalTime = Telemachus.telemetry["t.universalTime"] + (Date.now() - Telemachus.lastUpdate) / 1000;
        $("#met").text(missionTimeString(missionTime));
        return $("#ut").text(dateString(universalTime));
      }
    }, 1000);
    $("#telemetry form").submit(function(event) {
      event.preventDefault();
      return addTelemetry($("#apiSelect").val());
    });
    return $(window).resize(function() {
      var $alert, $chart, $display, $telemetry, $telemetryAdd, $telemetryForm, $telemetryList, $telemetrySelect, buttonWidth, canvas, display, margins, winHeight, _i, _j, _len, _len1, _ref2, _ref3, _ref4;
      winHeight = Math.min($(window).height(), (_ref2 = window.innerHeight) != null ? _ref2 : 1e6);
      $("#container").height(winHeight - ($("#container").position().top + $("body > footer").outerHeight(true)));
      _ref3 = $(".display", "#charts");
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        display = _ref3[_i];
        $display = $(display);
        $chart = $display.closest(".chart");
        $display.height($chart.height() - $display.position().top - 20);
        $alert = $display.siblings(".alert");
        $alert.css("fontSize", $display.height() / 5).css("marginTop", -($display.outerHeight() + $alert.height()) / 2);
      }
      _ref4 = $("canvas");
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        canvas = _ref4[_j];
        $(canvas).prop({
          width: $(canvas).width(),
          height: $(canvas).height()
        });
      }
      $telemetry = $("#telemetry");
      $telemetryList = $("dl", $telemetry);
      $telemetryForm = $("form", $telemetry);
      margins = $telemetryList.outerHeight(true) - $telemetryList.height();
      $telemetryList.height($telemetryForm.position().top - $telemetryList.position().top - margins);
      $("form", $telemetry).width($telemetry.width());
      $telemetrySelect = $("#apiSelect");
      $telemetryAdd = $("form input", $telemetry);
      buttonWidth = $telemetryAdd.outerWidth(true) + 5;
      return $telemetrySelect.width($telemetry.width() - buttonWidth);
    }).resize();
  });

  addTelemetry = function(api) {
    var $dd;
    if ((api != null) && api in Telemachus.api && $("#telemetry dd[data-api='" + api + "']").length === 0) {
      $("<dt>").data("api", api).text(Telemachus.api[api].name + " ").append($("<a>").attr({
        href: "#",
        title: "Remove"
      })).appendTo("#telemetry dl");
      $dd = $("<dd>").data("api", api).text("No Data").appendTo("#telemetry dl").on("telemetry", function(event, data) {
        var value;
        value = data[api];
        return $dd.text(Telemachus.format(value, api));
      });
      return Telemachus.subscribe($dd, api);
    }
  };

  removeTelemetry = function(elem) {
    var $elem;
    $elem = $(elem).next().addBack();
    Telemachus.unsubscribe($elem);
    return $elem.remove();
  };

  resetChart = function(elem) {
    var $display;
    $display = $(".display", elem).empty();
    return Telemachus.unsubscribe($display);
  };

  setChart = function(elem, chartName) {
    var $canvas, $display, $map, body, chart, map, marker, seriesData;
    resetChart(elem);
    chart = charts[chartName];
    if (chart == null) {
      return;
    }
    $("h2", elem).text(chartName);
    $display = $(".display", elem);
    Telemachus.subscribe.apply(Telemachus, [$display].concat(__slice.call(chart.series)));
    if (chart.type === "map") {
      $map = $("<div>").appendTo($display);
      map = new L.KSP.Map($map[0], {
        layers: [L.KSP.CelestialBody.KERBIN],
        zoom: L.KSP.CelestialBody.KERBIN.defaultLayer.options.maxZoom,
        center: [0, 0],
        bodyControl: false,
        layerControl: true,
        scaleControl: true
      });
      map.fitWorld();
      body = L.KSP.CelestialBody.KERBIN;
      marker = null;
      return $display.on("telemetry", function(event, data) {
        var bodyName, long, _ref;
        bodyName = (_ref = data["v.body"]) != null ? _ref.toUpperCase() : void 0;
        if (data["p.paused"] !== 0) {
          if (marker != null) {
            map.removeLayer(marker);
            return marker = null;
          }
        } else if (bodyName != null) {
          if (!(bodyName in L.KSP.CelestialBody)) {
            if ((bodyName != null) && (body != null)) {
              map.removeLayer(body);
              return body = null;
            }
          } else {
            if (body !== L.KSP.CelestialBody[data["v.body"].toUpperCase()]) {
              map.removeLayer(body);
              body = L.KSP.CelestialBody[data["v.body"].toUpperCase()];
              map.addLayer(body);
            }
            long = data["v.long"] > 180 ? data["v.long"] - 360 : data["v.long"];
            if (!(marker != null)) {
              marker = L.marker([data["v.lat"], data["v.long"]]);
              return map.addLayer(marker);
            } else {
              marker.setLatLng([data["v.lat"], long]);
              marker.bindPopup(data["v.name"] + " </br>Latitude: " + data["v.lat"] + "</br>Longitude: " + data["v.long"]);
              return marker.update();
            }
          }
        }
      });
    } else {
      $canvas = $("<canvas>").attr({
        width: $display.width(),
        height: $display.height()
      }).appendTo($display);
      seriesData = [];
      return $display.on("telemetry", function(event, data) {
        var chartHeight, chartWidth, ctx, dataValues, e, height, i, missionTime, sample, t, width, x, xmax, xmin, xscale, xticks, ymax, ymin, yscale, yticks, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        t = data["t.universalTime"];
        sample = (function() {
          var _i, _len, _ref, _results;
          _ref = chart.series;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            _results.push(data[e]);
          }
          return _results;
        })();
        for (i = _i = 0, _len = sample.length; _i < _len; i = ++_i) {
          e = sample[i];
          if ($.isArray(e)) {
            sample[i] = e[1][0];
          }
        }
        sample.unshift(t);
        seriesData = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = seriesData.length; _j < _len1; _j++) {
            e = seriesData[_j];
            if (e[0] < t && e[0] > t - 300) {
              _results.push(e);
            }
          }
          return _results;
        })();
        seriesData.push(sample);
        $canvas = $(".display canvas", elem);
        if ($canvas.length === 0) {
          return;
        }
        width = $canvas.width();
        height = $canvas.height();
        if (width === 0 || height === 0) {
          return;
        }
        chartWidth = width - 80;
        chartHeight = height - 40;
        ctx = $canvas[0].getContext('2d');
        ctx.save();
        ctx.clearRect(0, 0, width, height);
        xmin = t - 300;
        xmax = t;
        xscale = chartWidth / 300;
        missionTime = data["v.missionTime"];
        xticks = ((function() {
          var _j, _ref, _results;
          _results = [];
          for (x = _j = _ref = t - missionTime % 60; _j > xmin; x = _j += -60) {
            if (missionTime > 0 && (t - x - 0.01) <= missionTime) {
              _results.push(x);
            }
          }
          return _results;
        })()).reverse();
        if ((chart.yaxis.min != null) && (chart.yaxis.max != null)) {
          ymin = chart.yaxis.min;
          ymax = chart.yaxis.max;
        } else {
          dataValues = (function() {
            var _j, _len1, _ref, _ref1, _results;
            _ref1 = (_ref = []).concat.apply(_ref, (function() {
              var _k, _len1, _results1;
              _results1 = [];
              for (_k = 0, _len1 = seriesData.length; _k < _len1; _k++) {
                e = seriesData[_k];
                _results1.push(e.slice(1));
              }
              return _results1;
            })());
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              e = _ref1[_j];
              if (e != null) {
                _results.push(e);
              }
            }
            return _results;
          })();
          if (dataValues.length > 0) {
            ymin = (_ref = chart.yaxis.min) != null ? _ref : Math.min.apply(Math, dataValues);
            ymax = (_ref1 = chart.yaxis.max) != null ? _ref1 : Math.max.apply(Math, dataValues);
          } else {
            ymin = (_ref2 = (_ref3 = chart.yaxis.min) != null ? _ref3 : chart.yaxis.max) != null ? _ref2 : 0;
            ymax = (_ref4 = (_ref5 = chart.yaxis.max) != null ? _ref5 : chart.yaxis.min) != null ? _ref4 : 0;
          }
        }
        yticks = calculateTicks(ymin, ymax, chart.yaxis.min != null, chart.yaxis.max != null, ((height - 40) / 30) | 0);
        ymin = yticks[0];
        ymax = yticks[yticks.length - 1];
        yscale = chartHeight / (ymax - ymin);
        ctx.translate(70, height - 30);
        ctx.scale(1, -1);
        drawChartGrid(ctx, chartWidth, chartHeight, xmin, xscale, ymin, yscale, xticks, yticks);
        for (i = _j = _ref6 = chart.series.length; _ref6 <= 1 ? _j <= 1 : _j >= 1; i = _ref6 <= 1 ? ++_j : --_j) {
          drawChartSeries(ctx, xmin, xscale, ymin, yscale, seriesData, i);
        }
        ctx.clearRect(-70, -30, 70, height);
        ctx.clearRect(-70, -30, width, 30);
        drawChartAxes(ctx, chartWidth, chartHeight, ymin, yscale, yticks, chart.yaxis);
        if (chart.series.length > 1) {
          drawChartLegend(ctx, chartWidth, chart.series);
        }
        return ctx.restore();
      });
    }
  };

  calculateTicks = function(min, max, bottomFixed, topFixed, maxIntervals) {
    var bottom, i, interval, intervalAbove, intervalBelow, intervalValue, intervals, magnitude, nextBottom, nextInterval, nextTop, reduce, tick, ticks, top, _ref, _ref1, _ref2;
    reduce = function(interval) {
      switch (interval[0]) {
        case 5:
          return [2, interval[1]];
        case 2:
          return [1, interval[1]];
        case 1:
          return [5, interval[1] - 1];
      }
    };
    intervalValue = function(interval) {
      return interval[0] * Math.pow(10, interval[1]);
    };
    intervalAbove = function(num, interval) {
      var m, v;
      v = intervalValue(interval);
      m = num < 0 ? v + num % v : num % v;
      return num - m + v;
    };
    intervalBelow = function(num, interval) {
      var m, v;
      v = intervalValue(interval);
      m = num < 0 ? v + num % v : num % v;
      if (m === 0) {
        return num - v;
      } else {
        return num - m;
      }
    };
    if (max < min) {
      if (topFixed && bottomFixed) {
        _ref = [max, min], min = _ref[0], max = _ref[1];
      } else if (topFixed) {
        min = max;
      } else {
        max = min;
      }
    }
    if (maxIntervals < 1) {
      maxIntervals = 1;
    }
    bottom = min;
    top = max;
    if (bottomFixed && topFixed && top - bottom >= 90 && ((top - bottom) % 90 === 0)) {
      intervals = [15, 30, 45, 90];
      while (((top - bottom) / intervals[0]) > maxIntervals) {
        intervals.shift();
      }
      return (function() {
        var _i, _ref1, _results;
        _results = [];
        for (tick = _i = bottom, _ref1 = intervals[0]; bottom <= top ? _i <= top : _i >= top; tick = _i += _ref1) {
          _results.push(tick);
        }
        return _results;
      })();
    }
    if (min === max) {
      if (max === 0) {
        return [0, 1];
      } else {
        magnitude = orderOfMagnitude(max);
        interval = [1, magnitude];
        if (!bottomFixed) {
          bottom = intervalBelow(min, interval);
        }
        if (!(topFixed && !bottomFixed)) {
          top = intervalAbove(max, interval);
        }
        topFixed = bottomFixed = true;
      }
    } else {
      magnitude = Math.max(orderOfMagnitude(min), orderOfMagnitude(max));
      interval = [1, magnitude];
      if (!bottomFixed) {
        bottom = intervalBelow(min, interval);
      }
      if (!topFixed) {
        top = intervalAbove(min, interval);
      }
    }
    while (true) {
      nextInterval = reduce(interval);
      nextBottom = bottomFixed ? bottom : intervalBelow(min, nextInterval);
      nextTop = topFixed ? top : intervalAbove(max, nextInterval);
      if ((nextTop - nextBottom) / intervalValue(nextInterval) > maxIntervals) {
        break;
      }
      _ref1 = [nextBottom, nextTop, nextInterval], bottom = _ref1[0], top = _ref1[1], interval = _ref1[2];
    }
    ticks = [bottom, top];
    [].splice.apply(ticks, [1, 0].concat(_ref2 = (function() {
      var _i, _ref3, _ref4, _results;
      _results = [];
      for (i = _i = _ref3 = intervalAbove(bottom, interval), _ref4 = intervalValue(interval); _ref3 <= top ? _i < top : _i > top; i = _i += _ref4) {
        _results.push(i);
      }
      return _results;
    })())), _ref2;
    return ticks;
  };

  drawChartGrid = function(ctx, width, height, xoffset, xscale, yoffset, yscale, xticks, yticks) {
    var tick, x, y, _i, _j, _len, _len1;
    ctx.save();
    ctx.strokeStyle = 'rgb(96, 96, 96)';
    ctx.beginPath();
    for (_i = 0, _len = xticks.length; _i < _len; _i++) {
      tick = xticks[_i];
      x = Math.round(xscale * (tick - xoffset) - 0.5) + 0.5;
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
    }
    for (_j = 0, _len1 = yticks.length; _j < _len1; _j++) {
      tick = yticks[_j];
      y = Math.round(yscale * (tick - yoffset) - 0.5) + 0.5;
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
    }
    ctx.stroke();
    ctx.strokeStyle = 'rgb(192, 192, 192)';
    ctx.beginPath();
    y = Math.round(-yscale * yoffset - 0.5) + 0.5;
    ctx.moveTo(0, y);
    ctx.lineTo(width, y);
    ctx.stroke();
    return ctx.restore();
  };

  drawChartSeries = function(ctx, xmin, xscale, ymin, yscale, seriesData, i) {
    var SERIES_COLORS, d, j, _i, _len, _ref;
    SERIES_COLORS = ['rgb(192, 128, 0)', 'rgb(0, 128, 0)', 'rgb(0, 128, 192)', 'rgb(192, 192, 192)'];
    ctx.save();
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = SERIES_COLORS[i - 1];
    ctx.beginPath();
    for (j = _i = 0, _len = seriesData.length; _i < _len; j = ++_i) {
      d = seriesData[j];
      if (d[i] != null) {
        if (((_ref = seriesData[j - 1]) != null ? _ref[i] : void 0) != null) {
          ctx.lineTo(xscale * (d[0] - xmin), yscale * (d[i] - ymin));
        } else {
          ctx.moveTo(xscale * (d[0] - xmin), yscale * (d[i] - ymin));
        }
      }
    }
    ctx.stroke();
    return ctx.restore();
  };

  drawChartAxes = function(ctx, width, height, yoffset, yscale, yticks, yaxis) {
    var PREFIXES, prefix, tick, tickMagnitude, tickScale, y, _i, _j, _len, _len1;
    PREFIXES = ['f', 'p', 'n', '\u03bc', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
    ctx.save();
    ctx.strokeStyle = 'rgb(192, 192, 192)';
    ctx.beginPath();
    ctx.moveTo(-5, 0.5);
    ctx.lineTo(width + 0.5, 0.5);
    ctx.moveTo(0.5, 0);
    ctx.lineTo(0.5, height + 0.5);
    for (_i = 0, _len = yticks.length; _i < _len; _i++) {
      tick = yticks[_i];
      if (!(tick !== yoffset)) {
        continue;
      }
      y = Math.round(yscale * (tick - yoffset) - 0.5) + 0.5;
      ctx.moveTo(-5, y);
      ctx.lineTo(0.5, y);
    }
    ctx.stroke();
    tickMagnitude = Math.max(orderOfMagnitude(yticks[0]), orderOfMagnitude(yticks[yticks.length - 1]));
    if (tickMagnitude > 0) {
      tickMagnitude -= 1;
    }
    tickScale = Math.ceil(tickMagnitude / 3);
    if (tickScale > 0) {
      tickScale -= 1;
    }
    prefix = PREFIXES[tickScale + 5];
    ctx.font = 'bold 10pt "Helvetic Neue",Helvetica,Arial,sans serif';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgb(192, 192, 192)';
    ctx.scale(1, -1);
    ctx.save();
    ctx.textAlign = 'center';
    ctx.translate(-60, -height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText("" + yaxis.label + " (" + prefix + yaxis.unit + ")", 0, 0, height);
    ctx.restore();
    ctx.textAlign = 'right';
    tickScale = Math.pow(1000, -tickScale);
    for (_j = 0, _len1 = yticks.length; _j < _len1; _j++) {
      tick = yticks[_j];
      y = Math.round(yscale * (tick - yoffset) - 0.5) + 0.5;
      ctx.fillText(stripInsignificantZeros((tick * tickScale).toFixed(3)), -10, -y);
    }
    return ctx.restore();
  };

  drawChartLegend = function(ctx, width, series) {
    var SERIES_COLORS, api, apiWidths, i, legendWidth, x, _i, _len;
    SERIES_COLORS = ['rgb(192, 128, 0)', 'rgb(0, 128, 0)', 'rgb(0, 128, 192)', 'rgb(192, 192, 192)'];
    ctx.save();
    ctx.font = 'bold 10pt "Helvetic Neue",Helvetica,Arial,sans serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    apiWidths = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = series.length; _i < _len; _i++) {
        api = series[_i];
        _results.push(ctx.measureText(Telemachus.api[api].name).width);
      }
      return _results;
    })();
    legendWidth = (apiWidths.reduce(function(sum, width) {
      return sum + width;
    })) + (series.length - 1) * 40;
    ctx.scale(1, -1);
    x = width / 2 - legendWidth / 2;
    for (i = _i = 0, _len = series.length; _i < _len; i = ++_i) {
      api = series[i];
      ctx.fillStyle = SERIES_COLORS[i];
      ctx.fillRect(x, 17.5, 5, 5);
      ctx.fillStyle = 'rgb(192, 192, 192)';
      ctx.fillText(Telemachus.api[api].name, x + 10, 20);
      x += apiWidths[i] + 40;
    }
    return ctx.restore();
  };

  reloadLayout = function() {
    return setLayout($("h1").text().trim());
  };

  setLayout = function(name) {
    var elem, i, layout, telemetry, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
    if (name in layouts) {
      window.localStorage.setItem("defaultLayout", name);
      $("h1").text(name);
      layout = layouts[name];
      _ref = $("#telemetry dl dt");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        removeTelemetry(elem);
      }
      _ref1 = layout.telemetry;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        telemetry = _ref1[_j];
        addTelemetry(telemetry);
      }
      _ref2 = $(".chart");
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        elem = _ref2[i];
        _results.push(setChart(elem, layout.charts[i]));
      }
      return _results;
    }
  };

  orderOfMagnitude = function(v) {
    if (v === 0) {
      return 0;
    }
    return Math.floor(Math.log(Math.abs(v)) / Math.LN10 + 1.0000000000000001);
  };

  siUnit = function(v, unit) {
    var prefixes, scale;
    if (unit == null) {
      unit = "";
    }
    if (v === 0) {
      return "0 " + unit;
    }
    prefixes = ['\u03bc', 'm', '', 'k', 'M', 'G', 'T'];
    scale = Math.ceil(orderOfMagnitude(v) / 3);
    if (scale <= 0 && ++scale < 0) {
      scale = 0;
    } else if (scale === 1) {
      scale = 2;
    } else if (scale >= prefixes.length) {
      scale = prefixes.length - 1;
    }
    return (v / Math.pow(1000, scale - 2)).toPrecision(6) + " " + prefixes[scale] + unit;
  };

  stripInsignificantZeros = function(v) {
    return v.toString().replace(/((\.\d*?[1-9])|\.)0+($|e)/, '$2$3');
  };

  hourMinSec = function(t) {
    var hour, min, sec;
    hour = (t / 3600) | 0;
    if (hour < 10) {
      hour = "0" + hour;
    }
    t %= 3600;
    min = (t / 60) | 0;
    if (min < 10) {
      min = "0" + min;
    }
    sec = (t % 60).toFixed();
    if (sec < 10) {
      sec = "0" + sec;
    }
    return "" + hour + ":" + min + ":" + sec;
  };

  dateString = function(t) {
    var day, year;
    year = ((t / (365 * 24 * 3600)) | 0) + 1;
    t %= 365 * 24 * 3600;
    day = ((t / (24 * 3600)) | 0) + 1;
    t %= 24 * 3600;
    return "Year " + year + ", Day " + day + ", " + (hourMinSec(t)) + " UT";
  };

  missionTimeString = function(t) {
    var result;
    result = "T+";
    if (t >= 365 * 24 * 3600) {
      result += (t / (365 * 24 * 3600) | 0) + ":";
      t %= 365 * 24 * 3600;
      if (t < 24 * 3600) {
        result += "0:";
      }
    }
    if (t >= 24 * 3600) {
      result += (t / (24 * 3600) | 0) + ":";
    }
    t %= 24 * 3600;
    return result + hourMinSec(t) + " MET";
  };

  durationString = function(t) {
    var result;
    result = "";
    if (t >= 365 * 24 * 3600) {
      result += (t / (365 * 24 * 3600) | 0) + " years ";
      t %= 365 * 24 * 3600;
      if (t < 24 * 3600) {
        result += "0 days ";
      }
    }
    if (t >= 24 * 3600) {
      result += (t / (24 * 3600) | 0) + " days ";
    }
    t %= 24 * 3600;
    return result + hourMinSec(t);
  };

}).call(this);
